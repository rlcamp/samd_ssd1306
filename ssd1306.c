/* this is a microcontroller-agnostic, display-specific module allowing very basic pixel and text
 operation of an ssd1306 oled. it relies on an externally-provided i2c_write function which may or
 may not be nonblocking - if so, then display updates are nonblocking */

#include "ssd1306.h"
#include "i2c_write.h"

#include <string.h>

/* change this to 64 for the 128x64 oled, which automatically changes the i2c address */
#ifndef SCREEN_HEIGHT
#define SCREEN_HEIGHT 32
#endif
#define SCREEN_WIDTH 128

#define SSD1306_MEMORYMODE 0x20
#define SSD1306_COLUMNADDR 0x21
#define SSD1306_PAGEADDR 0x22
#define SSD1306_SETCONTRAST 0x81
#define SSD1306_CHARGEPUMP 0x8D
#define SSD1306_SEGREMAP 0xA0
#define SSD1306_DISPLAYALLON_RESUME 0xA4
#define SSD1306_NORMALDISPLAY 0xA6
#define SSD1306_SETMULTIPLEX 0xA8
#define SSD1306_DISPLAYOFF 0xAE
#define SSD1306_DISPLAYON 0xAF
#define SSD1306_COMSCANDEC 0xC8
#define SSD1306_SETDISPLAYOFFSET 0xD3
#define SSD1306_SETDISPLAYCLOCKDIV 0xD5
#define SSD1306_SETPRECHARGE 0xD9
#define SSD1306_SETCOMPINS 0xDA
#define SSD1306_SETVCOMDETECT 0xDB

#define SSD1306_SETSTARTLINE 0x40
#define SSD1306_DEACTIVATE_SCROLL 0x2E

static void ssd1306_init(void) {
    static char initted = 0;
    if (initted) return;
    initted = 1;

    const uint8_t i2caddr = (32 == SCREEN_HEIGHT) ? 0x3C : 0x3D;

    /* each of these blocks until the previous one has been sent */
    i2c_write(i2caddr, (uint8_t[]) { 0x0, SSD1306_DISPLAYOFF, SSD1306_SETDISPLAYCLOCKDIV, 0x80, SSD1306_SETMULTIPLEX, SCREEN_HEIGHT - 1 }, 6);
    i2c_write(i2caddr, (uint8_t[]) { 0x0, SSD1306_SETDISPLAYOFFSET, 0x0, SSD1306_SETSTARTLINE | 0x0, SSD1306_CHARGEPUMP, 0x14 }, 6);
    i2c_write(i2caddr, (uint8_t[]) { 0x0, SSD1306_MEMORYMODE, 0x00, SSD1306_SEGREMAP | 0x1, SSD1306_COMSCANDEC }, 5);
    i2c_write(i2caddr, (uint8_t[]) { 0x0, SSD1306_SETCOMPINS, 0x02, SSD1306_SETCONTRAST, 0x8F }, 5);
    i2c_write(i2caddr, (uint8_t[]) { 0x0, SSD1306_SETPRECHARGE, 0xF1 }, 3);
    i2c_write(i2caddr, (uint8_t[]) { 0x0, SSD1306_SETVCOMDETECT, 0x40, SSD1306_DISPLAYALLON_RESUME, SSD1306_NORMALDISPLAY, SSD1306_DEACTIVATE_SCROLL, SSD1306_DISPLAYON }, 7);

    /* block so that the array of arguments to the last cmd remains within scope while being sent */
    while (i2c_is_still_writing());
}

static void ssd1306_update(uint8_t * pixel_buffer) {
    ssd1306_init();
    const uint8_t i2caddr = (32 == SCREEN_HEIGHT) ? 0x3C : 0x3D;

    i2c_write(i2caddr, (uint8_t[]) { 0x0, SSD1306_PAGEADDR, 0, 0xFF, SSD1306_COLUMNADDR, 0, SCREEN_WIDTH - 1 }, 7);

    /* must pass a pixel buffer pointer that points at least one byte into the block */
    pixel_buffer[-1] = 0x40;

    /* non blocking, which is safe because the data being written does not go out of scope */
    i2c_write(i2caddr, pixel_buffer - 1, SCREEN_WIDTH * SCREEN_HEIGHT / 8 + 1);
}

static void enable_pixel_in_buffer(uint8_t * restrict const pixel_buffer, const size_t x, const size_t y, const char on) {
    const size_t ibyte = x + (y / 8) * SCREEN_WIDTH;
    if (ibyte >= SCREEN_WIDTH * SCREEN_HEIGHT / 8) return;
    if (on) pixel_buffer[ibyte] |= 1 << (y & 7);
    else pixel_buffer[ibyte] &= ~(1 << (y & 7));
}

uint16_t text_cursor_x, text_cursor_y;

/* double buffer. calling screen_clear() swaps buffers, allowing the prior buffer to continue to be
 streamed to the display while the new buffer is cleared and then drawed upon. one should either
 call screen_clear OR loop on screen_is_still_writing() between screen_refresh() and successive calls
 which modify the pixel buffer, ideally as late as possible in the latter case */
static uint8_t blocks[2][SCREEN_WIDTH * SCREEN_HEIGHT / 8 + 1];
static unsigned char ibuf = 0;
static uint8_t * pixel_buffer = blocks[0] + 1;

void screen_clear(void) {
    ibuf = !ibuf;
    pixel_buffer = blocks[ibuf] + 1;
    memset(pixel_buffer, 0, SCREEN_WIDTH * SCREEN_HEIGHT / 8);
    text_cursor_y = 0;
    text_cursor_x = 0;
}

void screen_refresh(void) {
    ssd1306_update(pixel_buffer);
}

int screen_is_still_writing(void) {
    return i2c_is_still_writing();
}

void screen_set_pixel(const size_t x, const size_t y, const char on) {
    enable_pixel_in_buffer(pixel_buffer, x, y, on);
}

/* this is the old school 7x5 font from adafruit */

#define FONT_HEIGHT 7
#define FONT_WIDTH 5
#define FONT_PITCH_VERTICAL 8
#define FONT_PITCH_HORIZONTAL 6

static const unsigned char font[95][5] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x5f, 0x00, 0x00 }, { 0x00, 0x07, 0x00, 0x07, 0x00 },
    { 0x14, 0x7f, 0x14, 0x7f, 0x14 }, { 0x24, 0x2a, 0x7f, 0x2a, 0x12 }, { 0x23, 0x13, 0x08, 0x64, 0x62 },
    { 0x36, 0x49, 0x56, 0x20, 0x50 }, { 0x00, 0x08, 0x07, 0x03, 0x00 }, { 0x00, 0x1c, 0x22, 0x41, 0x00 },
    { 0x00, 0x41, 0x22, 0x1c, 0x00 }, { 0x2a, 0x1c, 0x7f, 0x1c, 0x2a }, { 0x08, 0x08, 0x3e, 0x08, 0x08 },
    { 0x00, 0x80, 0x70, 0x30, 0x00 }, { 0x08, 0x08, 0x08, 0x08, 0x08 }, { 0x00, 0x00, 0x60, 0x60, 0x00 },
    { 0x20, 0x10, 0x08, 0x04, 0x02 }, { 0x3e, 0x51, 0x49, 0x45, 0x3e }, { 0x00, 0x42, 0x7f, 0x40, 0x00 },
    { 0x72, 0x49, 0x49, 0x49, 0x46 }, { 0x21, 0x41, 0x49, 0x4d, 0x33 }, { 0x18, 0x14, 0x12, 0x7f, 0x10 },
    { 0x27, 0x45, 0x45, 0x45, 0x39 }, { 0x3c, 0x4a, 0x49, 0x49, 0x31 }, { 0x41, 0x21, 0x11, 0x09, 0x07 },
    { 0x36, 0x49, 0x49, 0x49, 0x36 }, { 0x46, 0x49, 0x49, 0x29, 0x1e }, { 0x00, 0x00, 0x14, 0x00, 0x00 },
    { 0x00, 0x40, 0x34, 0x00, 0x00 }, { 0x00, 0x08, 0x14, 0x22, 0x41 }, { 0x14, 0x14, 0x14, 0x14, 0x14 },
    { 0x00, 0x41, 0x22, 0x14, 0x08 }, { 0x02, 0x01, 0x59, 0x09, 0x06 }, { 0x3e, 0x41, 0x5d, 0x59, 0x4e },
    { 0x7c, 0x12, 0x11, 0x12, 0x7c }, { 0x7f, 0x49, 0x49, 0x49, 0x36 }, { 0x3e, 0x41, 0x41, 0x41, 0x22 },
    { 0x7f, 0x41, 0x41, 0x41, 0x3e }, { 0x7f, 0x49, 0x49, 0x49, 0x41 }, { 0x7f, 0x09, 0x09, 0x09, 0x01 },
    { 0x3e, 0x41, 0x41, 0x51, 0x73 }, { 0x7f, 0x08, 0x08, 0x08, 0x7f }, { 0x00, 0x41, 0x7f, 0x41, 0x00 },
    { 0x20, 0x40, 0x41, 0x3f, 0x01 }, { 0x7f, 0x08, 0x14, 0x22, 0x41 }, { 0x7f, 0x40, 0x40, 0x40, 0x40 },
    { 0x7f, 0x02, 0x1c, 0x02, 0x7f }, { 0x7f, 0x04, 0x08, 0x10, 0x7f }, { 0x3e, 0x41, 0x41, 0x41, 0x3e },
    { 0x7f, 0x09, 0x09, 0x09, 0x06 }, { 0x3e, 0x41, 0x51, 0x21, 0x5e }, { 0x7f, 0x09, 0x19, 0x29, 0x46 },
    { 0x26, 0x49, 0x49, 0x49, 0x32 }, { 0x03, 0x01, 0x7f, 0x01, 0x03 }, { 0x3f, 0x40, 0x40, 0x40, 0x3f },
    { 0x1f, 0x20, 0x40, 0x20, 0x1f }, { 0x3f, 0x40, 0x38, 0x40, 0x3f }, { 0x63, 0x14, 0x08, 0x14, 0x63 },
    { 0x03, 0x04, 0x78, 0x04, 0x03 }, { 0x61, 0x59, 0x49, 0x4d, 0x43 }, { 0x00, 0x7f, 0x41, 0x41, 0x41 },
    { 0x02, 0x04, 0x08, 0x10, 0x20 }, { 0x00, 0x41, 0x41, 0x41, 0x7f }, { 0x04, 0x02, 0x01, 0x02, 0x04 },
    { 0x40, 0x40, 0x40, 0x40, 0x40 }, { 0x00, 0x03, 0x07, 0x08, 0x00 }, { 0x20, 0x54, 0x54, 0x78, 0x40 },
    { 0x7f, 0x28, 0x44, 0x44, 0x38 }, { 0x38, 0x44, 0x44, 0x44, 0x28 }, { 0x38, 0x44, 0x44, 0x28, 0x7f },
    { 0x38, 0x54, 0x54, 0x54, 0x18 }, { 0x00, 0x08, 0x7e, 0x09, 0x02 }, { 0x18, 0xa4, 0xa4, 0x9c, 0x78 },
    { 0x7f, 0x08, 0x04, 0x04, 0x78 }, { 0x00, 0x44, 0x7d, 0x40, 0x00 }, { 0x20, 0x40, 0x40, 0x3d, 0x00 },
    { 0x7f, 0x10, 0x28, 0x44, 0x00 }, { 0x00, 0x41, 0x7f, 0x40, 0x00 }, { 0x7c, 0x04, 0x78, 0x04, 0x78 },
    { 0x7c, 0x08, 0x04, 0x04, 0x78 }, { 0x38, 0x44, 0x44, 0x44, 0x38 }, { 0xfc, 0x18, 0x24, 0x24, 0x18 },
    { 0x18, 0x24, 0x24, 0x18, 0xfc }, { 0x7c, 0x08, 0x04, 0x04, 0x08 }, { 0x48, 0x54, 0x54, 0x54, 0x24 },
    { 0x04, 0x04, 0x3f, 0x44, 0x24 }, { 0x3c, 0x40, 0x40, 0x20, 0x7c }, { 0x1c, 0x20, 0x40, 0x20, 0x1c },
    { 0x3c, 0x40, 0x30, 0x40, 0x3c }, { 0x44, 0x28, 0x10, 0x28, 0x44 }, { 0x4c, 0x90, 0x90, 0x90, 0x7c },
    { 0x44, 0x64, 0x54, 0x4c, 0x44 }, { 0x00, 0x08, 0x36, 0x41, 0x00 }, { 0x00, 0x00, 0x77, 0x00, 0x00 },
    { 0x00, 0x41, 0x36, 0x08, 0x00 }, { 0x02, 0x01, 0x02, 0x04, 0x02 },
};

static void draw_character(uint16_t x, uint16_t y, unsigned char c) {
    if (x >= SCREEN_WIDTH || y >= SCREEN_HEIGHT) return;
    if (c < 32 || c > 126) c = ' ';

    for (size_t icol = 0; icol < FONT_WIDTH; icol++)
        for (size_t irow = 0; irow < FONT_HEIGHT; irow++)
            screen_set_pixel(x + icol, y + irow, (font[c - 32][icol] >> irow) & 1);
}

void screen_write_text(const char * string) {
    for (const char * cursor = string; *cursor != '\0'; cursor++) {
        const unsigned char c = *cursor;

        if (text_cursor_x + FONT_PITCH_HORIZONTAL > SCREEN_WIDTH && '\n' != c && '\r' != c) {
            text_cursor_x = 0;
            text_cursor_y += FONT_PITCH_VERTICAL;
        }

        while (text_cursor_y + FONT_PITCH_VERTICAL > SCREEN_HEIGHT) {
            //            while (screen_is_still_writing()) __WFI();

            /* very horrible hack, only works because of a series of coincidences */
            memmove(pixel_buffer, pixel_buffer + SCREEN_WIDTH * FONT_PITCH_VERTICAL / 8, SCREEN_WIDTH * (SCREEN_HEIGHT - FONT_PITCH_VERTICAL) / 8);
            memset(pixel_buffer + SCREEN_WIDTH * (SCREEN_HEIGHT - FONT_PITCH_VERTICAL) / 8, 0, SCREEN_WIDTH * FONT_PITCH_VERTICAL / 8);

            text_cursor_y -= FONT_PITCH_VERTICAL;
        }

        if ('\n' == c) {
            text_cursor_x = 0;
            text_cursor_y += FONT_PITCH_VERTICAL;
        }
        else if ('\r' == c)
            text_cursor_x = 0;
        else {
            draw_character(text_cursor_x, text_cursor_y, c);
            text_cursor_x += FONT_PITCH_HORIZONTAL;
        }
    }
}

char _screen_printf_buf[132];
